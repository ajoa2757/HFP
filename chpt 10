# HFP
Head_First_Python

Chpt 9 까지 진행하면서 , 우리는 로그를 생성하고 확인하는 과정까지 MySQL 데이터베이스를 사용하도록 완전히 대체하였다.

==============
웹 서버와 상태

클래스의 속성은 상태와 같다.

우리의 웹 어플리케이션에 상태를 사용할 수 있는가? (가령, 사용자의 권한 수준)

웹 코드에 변수를 제공하는 코드 하나를 사용하는 식으로는 일이 되지 않는다.

1. 전역변수를 이용하지 않고 웹 어플리케이션에 필요한 변수를 저장하는 방법
2. 각각의 사용자 데이터를 독립적으로 관리하는 방법

==============
세션

session 이라는, key & value 를 가지는 계층이 존재한다.

웹앱에는 원래 상태라는 개념이 존재하지 않는다. 이것은 flask 같은 개발 프레임워크들이 제공하는 기술이다.

0. app = Flask(__name__) 으로 웹앱을 생성한다.
1. session 을 flask 로부터 import 하여 시작한다.
2. app.secret_key 에 각자 정한 문자열 변수를 할당하여야 한다.
ㄴ>각자의 쿠키에 접근하기 위한 비밀번호와 같은 개념이다.

3. 이제 session 이라는 이름의 딕셔너리를 웹앱 안에서 사용할 수 있다. 


session 딕셔너리에는 웹앱의 사용에 필요한 여러가지 key 들이 세팅된 채로 존재한다. ?

우리는 이 세션이라는 딕셔너리에 값들만 전달하여 사용하게 된다.


=============
유저 세팅하기

@app.route('/setuser/<user>')
def setuser(user:str) -> str: 
  ...

ㄴ><user> 를 통해, url 에 입력된 user 를 변수로서 전달받는다.
ㄴ>문자열 'user' 를 key 로 하여, session dictionary 에 value 를 할당할 수 있다. 

============
세션 사용하기

getuser 함수 : session 의 키 'user' 에 해당하는값을 리턴하도록 함수를 만들었다.


브라우저를 모두 다르게 하여 이 웹앱을 사용하였을 때 확인할 수 있는 특이한 점이 있다.

1. 각자 다른 함수를 사용하면, 그들은 서로 다른 session 딕셔너리를 사용하는 것으로 보인다.
2. 이것은, 고유 쿠키 영역이 브라우저마다 -자동으로, 그리고 개별적으로- 생기고 있는 탓이다.

세션은 브라우저의 고유 쿠키값을 key 로 사용하는 딕셔너리이다.

session 의 user 라는 항목이 브라우저마다 다르게 설정될 수 있는 것이다.

============
session['logged_in']

우리는, session 딕셔너리의 logged_in 값을 True / NULL 로 사용할 것이다.

/login url 에서는 이 값을 True 로 만들 것이고,
/logout url 에서는 앞서 만든 값을 pop 해줄 것이다.

Q. 왜 이렇게 하는가?

A. 아직 로그인을 하지 않은 상태에서는 세션의 logged_in 이 정의되지 않은 상태다.

우리는 이어지는 코드에서도, 로그인이 되었으면 True/ 아니면 NULL 인 이 상태의 일관성을 유지하고 싶다.
 
 
 
따라서, /status URl 에서 사용자의 로그인 여부를 체크하는 코드를 작성할 때에도, 
if 'logged_in' in session:

...과 같은 방식으로, logged in 이 NULL 인지 아닌지를 체크하도록 할 것이다.
 
===========
~423 페이지까지

이렇게 지금까지 여러 메서드를 만들었다.
 
session['user'] 계통 : setuser, getuser, 
session['logged_in'] 계통 : login, logout, status

*session 을 사용하기 위한 사전작업은 app.secret_key 에 알맞은 문자열 값이 들어가 있는 것이다.

===========
로그인 로직 적용하기

자. 우리는 위의 과정들을 통해, 유저를 식별하고 로그인 여부를 확인하는 기능을 만들었다.

이것을 어떻게 기존 코드에 삽입할 수 있을까?

1. 로그인 로직을 모든 URL 에 하나씩 복사 붙여넣기하여 추가한다.
ㄴ>우리는 이런 작업을 하는 대신, 함수를 사용하여 코드를 재사용 하였었다.

2. 로직을 함수로 만들어 모든 URL 에 추가한다.
ㄴ>1번과 사실상 다르지 않은 작업을 모든 URL 에 해줘야 한다.


이것을 개선하기 위해, 장식자에 대해 심화 과정을 배운다.

=============
매개변수로 함수 전달하기.

함수를 매개변수로 하는 함수 역시 만들 수 있다.

def apply(func: object, value: object) 
  return func(value)
ㄴ> 어노테이션에 object 가 적혀 있다. 이것은 어떤 객체든 여기 올 수 있다는 뜻이다.
ㄴ> 함수 역시 객체의 한 종류이다. 즉 apply 의 fucn 인자는 함수일 수 있다.

ㄴ>return 문에서 보이듯이, 전달받은 함수를 호출하여 사용할 수도 있다.

============
함수 안에서 함수 정의하기.

복잡도가 높은 함수의 경우, 일부 기능을 함수 스위트 내부에서 함수로 만들어 버림으로써, 기능을 추상화할 수 있다.


가령, outer 라는 함수 안에 inner 라는 함수가 정의되어 있다고 하자.

outer 는 inner 라는 함수 객체를 반환한다.

1. i = outer() 

이 명령문은, outer를 호출하는 동시에, outer 의 반환값인 inner 함수객체를 변수 i 에 저장한다. 

2. i()

이 명령문은, i 안에 저장된 함수객체 inner 를 호출한다.

=============
여러개의 인자 사용하기

def func(*args):
  for a in args:
    ...
ㄴ>특수기호 '*'를 사용하여, 함수에 인자를 여러개 전달할 수 있다.
ㄴ>또한, 전달된 args 는 a 라는 반복인자를 사용하여 하나하나 개별적으로 처리할 수 있다.

ㄴ>만약 args 자리에 한 개의 리스트 arr 이 전달되었다고 하자.
ㄴ>함수 호출 시 func(*arr) 과 같이 전달하면, arr의 인자 하나하나가 개별적으로 args 로 전달된 것 처럼 동작한다.

============
키워드 인자 사용하기

**를 사용하면 키워드 인자를 사용할 수 있다.


